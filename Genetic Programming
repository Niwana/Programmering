import Control.Applicative
import Control.Arrow (second)
import Control.Monad (liftM, replicateM)
import Control.Monad.Random
import Data.Function (on)
import Data.List (minimumBy, sortBy, nub, (\\))
import Data.Ord (comparing)
import Text.Printf (printf)
import Test.QuickCheck
import Test.QuickCheck.Monadic
import Test.HUnit hiding (assert)
import System.Random
import System.IO
import System.IO.Unsafe
import Data.Char

target = "hejsan"

population :: Int
population = 100

mutation_promille = 12

fstParent_procent = 50

-- lyft in target, population_procent, mutation_promille och fstParent_procent i getline main?

randomString :: IO String
randomString = (liftM (take (length target) . randomRs (' ', 'z')) newStdGen)     

generations :: IO [String]
generations = replicateM population randomString 

startGen :: [String]
startGen = unsafePerformIO generations

goodOrNot :: String -> String -> Int
goodOrNot _ [] = 0
goodOrNot [] _ = 0
goodOrNot (x:xs) (y:ys) = if x /= y then 1 + (goodOrNot xs ys) else (goodOrNot xs ys)

values :: [String] -> [Int]
values [] = []
values (x:xs) = (goodOrNot x target) : (values xs)

valueTuples :: [String] -> [(String, Int)] 
valueTuples x = 
    sortBy (compare `on` snd) (zip x (values x))
--    newParentToTemp x

progenitor = do 
    writeFile "utveckling.txt" ("Target = " ++ target ++ "\nPopulation = " ++ (show population) ++ "\nMutationfactor = " ++ (show mutation_promille) ++ " promille\n\n1. " ++ (fst (head(take 1 (valueTuples startGen)))) ++ " (" ++ (show (head (map snd (take 1 (valueTuples startGen))))) ++ " fel)")
    newParentToTemp startGen
    
newParentToTemp x = do 
    writeFile "fst.temp" (fst (head( take 1 (valueTuples x))))
    writeFile "snd.temp" (fst (head ( take 1 (drop 1 (valueTuples x)))))

randomLetter = (getStdRandom (randomR ('a', 'z')))
randomPromille = getStdRandom (randomR (0, (length [1..1000])))
randomProcent = getStdRandom (randomR (0, (length [1..100])))

descendant = length target

mutate :: [Char] -> [Char]
mutate [] = [] 
mutate (x:xs) = if mutation_promille >= (do unsafeDupablePerformIO randomPromille) then (do unsafeDupablePerformIO randomLetter) : mutate (xs) else x : mutate (xs)

recordBest x y = do appendFile "utveckling.txt" ("\n" ++ (show y) ++ ". " ++ (fst (head(take 1 (valueTuples x)))) ++ " (" ++ (show (head (map snd (take 1 (valueTuples x))))) ++ " fel)")

------------------------------------------------------------------------------------

main = do
    progenitor
