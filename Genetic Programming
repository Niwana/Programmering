import Control.Applicative
import Control.Arrow (second)
import Control.Monad (liftM, replicateM)
import Control.Monad.Random
import Data.Function (on)
import Data.List (minimumBy, sortBy, nub, (\\))
import Data.Ord (comparing)
import Text.Printf (printf)
import Test.QuickCheck
import Test.QuickCheck.Monadic
import Test.HUnit hiding (assert)
import System.Random
import System.IO
import System.IO.Unsafe
import Data.Char
import Control.DeepSeq
import Control.Exception

target = "hejsan"

population :: Int
population = 100

mutation_promille = 12

fstParent_procent = 50

-- lyft in target, population_procent, mutation_promille och fstParent_procent i getline main?

randomString :: IO String
randomString = (liftM (take (length target) . randomRs (' ', 'z')) newStdGen)     

generations :: IO [String]
generations = replicateM population randomString 

startGen :: [String]
startGen = unsafePerformIO generations

goodOrNot :: String -> String -> Int
goodOrNot _ [] = 0
goodOrNot [] _ = 0
goodOrNot (x:xs) (y:ys) = if x /= y then 1 + (goodOrNot xs ys) else (goodOrNot xs ys)

values :: [String] -> [Int]
values [] = []
values (x:xs) = (goodOrNot x target) : (values xs)

valueTuples :: [String] -> [(String, Int)] 
valueTuples x = 
    sortBy (compare `on` snd) (zip x (values x))

progenitor = do 
    writeFile "utveckling.txt" ("Target = " ++ target ++ "\nPopulation = " ++ (show population) ++ "\nMutationfactor = " ++ (show mutation_promille) ++ " promille\n" )
    writeFile "genCount.temp" (show 0)
    newParentToTemp startGen
    
newParentToTemp x = do 
    writeFile "fst.temp" (fst (head( take 1 (valueTuples x))))
    writeFile "snd.temp" (fst (head ( take 1 (drop 1 (valueTuples x)))))
    file <- readFile "genCount.temp"
    evaluate (force file)
    writeFile "genCount.temp" (show (digitToInt (head (file)) + 1))
    recordBest x
    if (head (map snd (take 1 (valueTuples x)))) == 0 then putStrLn (show (digitToInt (head (file)) + 1))
    else putStrLn "problem hÃ¤r i loopen"
    --else newParentToTemp (descendant (population))
    --else do main2
    
recordBest x = do appendFile "utveckling.txt" ("\n" ++ (unsafePerformIO(readFile "genCount.temp")) ++ ". " ++ (fst (head(take 1 (valueTuples x)))) ++ " (" ++ (show (head (map snd (take 1 (valueTuples x))))) ++ " fel)")
    
randomLetter = (getStdRandom (randomR ('a', 'z')))
randomPromille = getStdRandom (randomR (0, (length [1..1000])))
randomProcent = getStdRandom (randomR (0, (length [1..100])))

descendant :: Int -> [String]
descendant 0 = []
descendant n = (mutate fst snd) : (descendant (n-1))
           where fst = unsafePerformIO (readFile "fst.temp") -- head (unsafePerformIO (withFile "fst.temp" ReadMode getlines)) --
                 snd = unsafePerformIO (readFile "snd.temp")
                 
getlines :: Handle -> IO [String]
getlines h = lines `fmap` hGetContents h           
    
mutate :: [Char] -> [Char] -> [Char]
mutate _ [] = []
mutate [] _ = [] 
mutate (x:xs) (y:ys) = if mutation_promille >= (do unsafeDupablePerformIO randomPromille) then (do unsafeDupablePerformIO randomLetter) : mutate (xs) (ys) else if fstParent_procent >= (do unsafeDupablePerformIO randomProcent) then x : (mutate xs ys) else y : (mutate xs ys)



------------------------------------------------------------------------------------

main = do
    progenitor
