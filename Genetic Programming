import Control.Applicative
import Control.Arrow (second)
import Control.Monad (liftM, replicateM)
import Control.Monad.Random
import Data.Function (on)
import Data.List (minimumBy, sortBy, nub, (\\))
import Data.Ord (comparing)
import Text.Printf (printf)
import Test.QuickCheck
import Test.QuickCheck.Monadic
import Test.HUnit hiding (assert)
import System.Random
import System.IO
import System.IO.Unsafe
import Data.Char
import Control.DeepSeq
import Control.Exception

target = "Hejsan martin, jag tror att det funkar :) gjorde bara ett dumt fel och missade att ta bort tempfilerna"

population :: Int
population = 100

mutation_promille = 12

fstParent_procent = 50

randomString :: IO String
randomString = (liftM (take (length target) . randomRs (' ', '~')) newStdGen)     

generations :: IO [String]
generations = replicateM population randomString 

startGen :: [String]
startGen = unsafePerformIO generations

goodOrNot :: String -> String -> Int
goodOrNot _ [] = 0
goodOrNot [] _ = 0
goodOrNot (x:xs) (y:ys) = if x /= y then 1 + (goodOrNot xs ys) else (goodOrNot xs ys)

values :: [String] -> [Int]
values [] = []
values (x:xs) = (goodOrNot x target) : (values xs)

valueTuples :: [String] -> [(String, Int)] 
valueTuples x = 
    sortBy (compare `on` snd) (zip x (values x))

progenitor = do 
    writeFile "utveckling.txt" ("Target = " ++ target ++ "\nPopulation = " ++ (show population) ++ "\nMutationfactor = " ++ (show mutation_promille) ++ " promille\n" )
    writeFile "genCount.temp" (show 0)
    newParentToTemp startGen 1
    
newParentToTemp x n = do 
    recordBest x n
    writeFile "fst.temp" (fst (head( take 1 (valueTuples x))))
    writeFile "snd.temp" (fst (head ( take 1 (drop 1 (valueTuples x)))))
    if (head (map snd (take 1 (valueTuples x)))) == 0 then putStrLn (show n)
    else newParentToTemp (descendant (population)) (n+1)
        
recordBest x n = do appendFile "utveckling.txt" ("\n" ++ (show n) ++ ". " ++ (fst (head(take 1 (valueTuples x)))) ++ " (" ++ (show (head (map snd (take 1 (valueTuples x))))) ++ " fel)")
    
randomLetter = (getStdRandom (randomR (' ', '~')))
randomPromille = getStdRandom (randomR (0, (length [1..1000])))
randomProcent = getStdRandom (randomR (0, (length [1..100])))

descendant :: Int -> [String]
descendant 0 = []
descendant n = (mutate (unsafePerformIO firstp) (unsafePerformIO secondp)) : (descendant (n-1))
                 
firstp = do 
    firstp <- readFile "fst.temp"
    evaluate (force firstp)

secondp = do
    secondp <- readFile "snd.temp"
    evaluate (force secondp)

mutate :: [Char] -> [Char] -> [Char]
mutate _ [] = []
mutate [] _ = [] 
mutate (x:xs) (y:ys) = if mutation_promille >= (do unsafeDupablePerformIO randomPromille) then (do unsafeDupablePerformIO randomLetter) : mutate (xs) (ys) else if fstParent_procent >= (do unsafeDupablePerformIO randomProcent) then x : (mutate xs ys) else y : (mutate xs ys)

-----------------------------------------------------------------------------

main = do
    progenitor
